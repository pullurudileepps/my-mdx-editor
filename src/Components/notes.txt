// turndownSetup.js  (import this where needed)
import TurndownService from 'turndown';
import { gfm } from 'turndown-plugin-gfm';
import { decode } from 'html-entities';

// create a configured turndown instance
export function createTurndown() {
  const td = new TurndownService({
    headingStyle: 'atx',
    codeBlockStyle: 'fenced',
    bulletListMarker: '-',
    emDelimiter: '_',
    strongDelimiter: '**',
  });

  // Attach GFM plugin (tables, strikethrough, autolink, task lists)
  td.use(gfm);

  // 1) Preserve anchor tags that have target or rel (so attrs survive round-trip).
  //    Return raw <a ...> HTML so markdown -> html round-trip preserves attributes.
  td.addRule('preserveAnchorWithAttrs', {
    filter: (node) => {
      if (node.nodeName !== 'A') return false;
      const href = node.getAttribute && node.getAttribute('href');
      // preserve if special attrs exist (target/rel/data-*)
      return !!href && (
        node.hasAttribute('target') ||
        node.hasAttribute('rel') ||
        Array.from(node.attributes).some(a => a.name.startsWith('data-'))
      );
    },
    replacement: (content, node) => {
      // build safe attribute string (keep only some attrs)
      const allowed = ['href','title','target','rel','id','class','data-*'];
      const attrs = Array.from(node.attributes).map(attr => {
        // keep data-* and allowed list
        if (attr.name.startsWith('data-')) return `${attr.name}="${attr.value}"`;
        if (allowed.includes(attr.name)) return `${attr.name}="${attr.value}"`;
        return '';
      }).filter(Boolean).join(' ');
      return `<a ${attrs}>${content}</a>`;
    }
  });

  // 2) Generic inline-unwrap rule: for many inline tags that don't need explicit markup
  //    (ins, span, font, bdi, u-like but not <strong>/<em>), just return inner text.
  const INLINE_UNWRAP = new Set(['INS','SPAN','FONT','BDI','BDO','SMALL','S','VAR','KBD','MARK']);
  td.addRule('unwrapInlineTags', {
    filter: (node) => {
      return node.nodeType === 1 && INLINE_UNWRAP.has(node.nodeName);
    },
    replacement: (content) => content || ''
  });

  // 3) Fallback: block-level unknown tags -> convert to their inner HTML block
  //    (If you prefer to keep them as raw HTML you can return node.outerHTML instead.)
  td.addRule('blockFallback', {
    filter: (node) => {
      if (node.nodeType !== 1) return false;
      const blockTags = new Set(['DIV','SECTION','ARTICLE','ASIDE','NAV','HEADER','FOOTER','FIGURE']);
      return blockTags.has(node.nodeName);
    },
    replacement: (content, node) => {
      // keep inner content and ensure separated by double newlines (Markdown block)
      return `\n\n${content || ''}\n\n`;
    }
  });

  // 4) optional: normalize NBSP and decode entities first
  function htmlToMarkdown(html) {
    if (!html) return '';
    // decode entities first (so &amp; &nbsp; etc become characters)
    let decoded = decode(html);
    // replace NBSP with normal space (or keep as &nbsp; if you prefer)
    decoded = decoded.replace(/\u00A0/g, ' ');
    // return the turndown result
    return td.turndown(decoded);
  }

  return { td, htmlToMarkdown };

}
***********************

'use client';
import React from "react";
import ReactMarkdown from "react-markdown";

import remarkParse from "remark-parse";
import remarkGfm from "remark-gfm";
import remarkEmoji from "remark-emoji";
import remarkMath from "remark-math";
import remarkRehype from "remark-rehype";

import rehypeRaw from "rehype-raw";
import rehypeSlug from "rehype-slug";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import rehypeStringify from "rehype-stringify";
import DOMPurify from "dompurify";

// GFM Footnotes (NON-deprecated)
import { gfmFootnote } from "micromark-extension-gfm-footnote";
import { gfmFootnoteFromMarkdown } from "mdast-util-gfm-footnote";

const schema = {
  ...defaultSchema,
  attributes: {
    ...defaultSchema.attributes,
    a: [
      ...(defaultSchema.attributes?.a || []),
      ["target"],
      ["rel"],
      ["aria-hidden"],
      ["id"]
    ],
    "*": [
      ...(defaultSchema.attributes?.["*"] || []),
      ["class"],
      ["style"],
      ["data-*"],
      ["aria-*"]
    ]
  }
};

function sanitizeAndFix(html) {
  const clean = DOMPurify.sanitize(html, { ADD_ATTR: ["target", "rel"] });
  return clean.replace(/\u00A0/g, "&nbsp;");
}

export default function MarkdownRenderer({ markdown = "" }) {
  const input = markdown.replace(/\u00A0/g, "&nbsp;");

  return (
    <ReactMarkdown
      children={input}
      remarkPlugins={[
        remarkParse,
        remarkGfm,       // tables, lists, strikethrough, autolinks, footnote refs
        remarkEmoji,
        remarkMath,
      ]}
      // this is the OFFICIAL 2025 footnote pipeline
      remarkRehypeOptions={{
        footnoteLabel: "Footnotes",
        footnoteBackLabel: "↩",
        extensions: [gfmFootnote()],
        mdastExtensions: [gfmFootnoteFromMarkdown()],
        allowDangerousHtml: true
      }}
      rehypePlugins={[
        rehypeRaw,
        rehypeSlug,
        [
          rehypeAutolinkHeadings,
          { behavior: "append", properties: { class: "anchor-link" } }
        ],
        [rehypeSanitize, schema]
      ]}
      transformHtml={(html) => sanitizeAndFix(html)}
    />
  );
}
***************


// GithubMarkdownEditor.jsx
'use client';
import React, { useMemo, useCallback } from 'react';
import ReactMarkdown from 'react-markdown';

import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkEmoji from 'remark-emoji';
import remarkRehype from 'remark-rehype';

import rehypeRaw from 'rehype-raw';
import rehypeSlug from 'rehype-slug';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypeSanitize, { defaultSchema } from 'rehype-sanitize';
import rehypeStringify from 'rehype-stringify';

import DOMPurify from 'dompurify';

import TurndownService from 'turndown';
import { gfm } from 'turndown-plugin-gfm';

// Extended sanitize schema to allow target, rel, data-*, aria-* etc.
const sanitizeSchema = {
  ...defaultSchema,
  attributes: {
    ...defaultSchema.attributes,
    a: [
      ...(defaultSchema.attributes?.a || []),
      ['target'],
      ['rel'],
      ['id'],
      ['aria-hidden'],
      ['data-sourcepos']
    ],
    '*': [
      ...(defaultSchema.attributes?.['*'] || []),
      ['class'],
      ['style'],
      ['data-*'],
      ['aria-*']
    ]
  }
};

// --------------------
// Markdown -> HTML
// --------------------
export async function markdownToHtml(markdownString) {
  // Ensure non-breaking spaces are preserved early if present
  const normalized = (markdownString ?? '').replace(/\u00A0/g, '&nbsp;');

  const processor = unified()
    .use(remarkParse)
    .use(remarkGfm)       // tables, task lists, autolinks, strikethrough, footnotes (GFM)
    .use(remarkMath)      // optional math support
    .use(remarkEmoji)     // emoji shortcodes
    .use(remarkRehype, { allowDangerousHtml: true }) // convert to rehype, keep HTML
    .use(rehypeRaw)       // parse embedded HTML inside markdown
    .use(rehypeSlug)      // add id attributes to headings
    .use(rehypeAutolinkHeadings, { behavior: 'append', properties: { class: 'anchor-link', 'aria-hidden': 'true' } })
    .use(rehypeSanitize, sanitizeSchema)
    .use(rehypeStringify);

  const file = await processor.process(normalized);
  // final sanitize with DOMPurify to be extra safe & ensure target/rel allowed
  const html = String(file);
  const clean = DOMPurify.sanitize(html, { ADD_ATTR: ['target', 'rel', 'id', 'aria-hidden'] });
  // Ensure non-breaking spaces rendered as &nbsp;
  return clean.replace(/\u00A0/g, '&nbsp;');
}

// --------------------
// HTML -> Markdown (Turndown with GFM plugin + rules)
// --------------------
export function htmlToMarkdown(htmlString) {
  const td = new TurndownService({
    headingStyle: 'atx',
    codeBlockStyle: 'fenced',
    linkStyle: 'inlined',
    bulletListMarker: '-'
  });

  // add GFM plugin (tables, strikethrough, task lists)
  td.use(gfm);

  // Keep <ins> content but drop the tag (user asked "not considering <ins>")
  td.addRule('stripIns', {
    filter: 'ins',
    replacement: (content) => content || ''
  });

  // preserve non-breaking spaces as &nbsp; (we convert back to \u00A0 in md)
  td.addRule('preserveNbsp', {
    filter: function (node) {
      return node.nodeType === 3 && /\u00A0/.test(node.nodeValue || '');
    },
    replacement: function (content) {
      return content.replace(/\u00A0/g, '&nbsp;');
    }
  });

  // Allow data-* attributes conversion (no-op here; turndown converts HTML to md)
  let md = td.turndown(htmlString || '');

  // convert &nbsp; back to literal NBSP (so markdown->html roundtrip can preserve it)
  md = md.replace(/&nbsp;/g, '\u00A0');

  // trim some trailing whitespace while keeping necessary newlines
  return md;
}

// --------------------
// React functional component with GitHub rendering
// --------------------
export default function GithubMarkdownRenderer({
  markdown = '',
  // optional callbacks for save/retrieve flows (user will integrate with redux)
  onSaveHtml = null
}) {
  // memoized HTML computed from markdown
  const html = useMemo(() => {
    // synchronous wrapper: call markdownToHtml which is async.
    // We'll run it synchronously with a quick self-invoking async; but since React render must be sync,
    // useMemo returns placeholder and caller typically will use the helper function directly.
    // For convenience we call markdownToHtml synchronously by blocking using .then — preferred: caller uses markdownToHtml directly.
    // Here we return the sanitized output if you already have it precomputed (safe pattern).
    // BUT most predictable approach: return null and provide explicit helper usage.
    return null;
  }, [markdown]);

  // callback to convert markdown -> html (async)
  const convertMdToHtml = useCallback(async (md) => {
    return await markdownToHtml(md);
  }, []);

  // callback to convert html -> markdown (sync)
  const convertHtmlToMd = useCallback((html) => {
    return htmlToMarkdown(html);
  }, []);

  // example onSave wrapper (if onSaveHtml provided)
  const handleSave = useCallback(async (md) => {
    const htmlOut = await convertMdToHtml(md);
    if (typeof onSaveHtml === 'function') onSaveHtml(htmlOut);
    return htmlOut;
  }, [convertMdToHtml, onSaveHtml]);

  // Render: We use ReactMarkdown for client-side rendering (fast), but the consumer
  // may call markdownToHtml() for server or DB storage.
  const preview = useMemo(() => {
    // Preprocess replace NBSP before rendering so ReactMarkdown displays them
    const input = (markdown || '').replace(/\u00A0/g, '&nbsp;');
    return input;
  }, [markdown]);

  // custom components for ReactMarkdown: preserve attributes and avoid leaking node prop into DOM elements
  const components = useMemo(() => ({
    // generic image: prevent node prop leak
    img({ src, alt, title, ...rest }) {
      return <img src={src} alt={alt ?? ''} title={title ?? ''} {...rest} />;
    },
    // inline code style (red) and block code handled by SyntaxHighlighter if desired
    code({ inline, className, children }) {
      if (inline) {
        return <code style={{ color: '#ef4444' }}>{children}</code>;
      }
      // fallback plain block
      return <pre><code className={className}>{children}</code></pre>;
    },
    // headings: attach anchor wrapper (GitHub-style)
    h2(props) {
      const text = String(props.children);
      const id = 'user-content-' + text.toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]/g, '');
      return (
        <h2 id={id} className="anchor-wrapper">
          <a className="anchor" aria-hidden="true" href={`#${id}`}></a>
          {props.children}
        </h2>
      );
    },
    // allow other tags to keep their props (table, blockquote, etc). You can add more as needed.
  }), []);

  return (
    <div className="github-md-renderer">
      <ReactMarkdown
        children={preview || ''}
        remarkPlugins={[remarkGfm, remarkMath, remarkEmoji]}
        rehypePlugins={[rehypeRaw, rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'append', properties: { class: 'anchor-link', 'aria-hidden': 'true' } }], [rehypeSanitize, sanitizeSchema]]}
        components={components}
      />
      {/* Expose helpers on the DOM for integration testing if required */}
      <div style={{ display: 'none' }} data-debug-md={markdown} />
      {/* NOTE: for server-side saving / DB you SHOULD call markdownToHtml(markdown) directly (it returns Promise<string>) */}
    </div>
  );
}

*************

https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax


*****

// sanitize-config.js
import DOMPurify from 'dompurify';

/**
 * DOMPurify config: ADD_TAGS and ADD_ATTR extend the allowed list.
 * Use DOMPurify.sanitize(html, { ADD_TAGS, ADD_ATTR }) or setConfig as shown.
 */

export const DOMPURIFY_CONFIG = {
  ADD_TAGS: [
    // structural / common
    'article','section','nav','header','footer','main','details','summary',

    // text-level / inline
    'a','abbr','b','strong','i','em','u','mark','small','sub','sup','code','pre','kbd','samp','var','time',

    // lists / tables
    'ul','ol','li','dl','dt','dd','table','thead','tbody','tfoot','tr','th','td','caption','col','colgroup',

    // media / embedded
    'img','figure','figcaption','picture','source','video','audio','iframe',

    // form / interactive (task-lists)
    'input','label','button','select','option','textarea',

    // structural inline wrappers
    'div','span','p','blockquote','hr'
  ],
  ADD_ATTR: [
    // global
    'id','class','style','title','role','data-sourcepos','data-*',

    // links/images
    'href','src','alt','srcset','sizes','loading','width','height','decoding','crossorigin',

    // anchors
    'target','rel','download',

    // table attributes
    'colspan','rowspan','scope',

    // input/form attributes (task lists)
    'type','checked','disabled','value','name','placeholder','autocomplete','readonly','required','multiple','selected','tabindex',

    // code/pre
    'lang','language','class', // e.g. class="language-js"

    // aria (explicit common ones; add others as needed)
    'aria-hidden','aria-label','aria-labelledby','aria-describedby'
  ],
  // keep content of removed nodes, if desired
  KEEP_CONTENT: true
};

// Example: set global config once
DOMPurify.setConfig({
  ADD_TAGS: DOMPURIFY_CONFIG.ADD_TAGS,
  ADD_ATTR: DOMPURIFY_CONFIG.ADD_ATTR
});

// Export a helper
export function cleanHtmlWithDOMPurify(html) {
  return DOMPurify.sanitize(html, {
    ADD_TAGS: DOMPURIFY_CONFIG.ADD_TAGS,
    ADD_ATTR: DOMPURIFY_CONFIG.ADD_ATTR
  });
}

***********

// rehypeSanitizeConfig.js
import { defaultSchema } from 'rehype-sanitize';

/**
 * Extend the default rehype-sanitize schema to allow input and other tags/attributes.
 * This is safe because we sanitize after allowing raw HTML (do NOT use allowDangerousHtml without a sanitize step).
 */

export const rehypeSanitizeSchema = {
  ...defaultSchema,

  // ensure tagNames contains everything we want
  tagNames: Array.from(new Set([
    ...(defaultSchema.tagNames || []),
    // add tags we want to allow
    'article','section','nav','header','footer','main','details','summary',
    'abbr','mark','time','kbd','samp','var',
    'figure','figcaption','picture','source','video','audio','iframe',
    'pre','code',
    'table','thead','tbody','tfoot','tr','th','td','caption','col','colgroup',
    'input','label','button','select','option','textarea',
    'div','span','p','blockquote','hr'
  ])),

  // Attributes: extend/default
  attributes: {
    // keep the default attributes for all tags
    ...(defaultSchema.attributes || {}),

    // global attributes on any tag (rehype uses '*' to denote any tag)
    '*': [
      // merge default wildcard attrs (if any) with our extras
      ...(defaultSchema.attributes && defaultSchema.attributes['*'] ? defaultSchema.attributes['*'] : []),
      'id','class','style','title','role','data-sourcepos','tabindex'
    ],

    // anchors
    a: [
      ...(defaultSchema.attributes && defaultSchema.attributes.a ? defaultSchema.attributes.a : []),
      'href','target','rel','download','title'
    ],

    // images
    img: [
      ...(defaultSchema.attributes && defaultSchema.attributes.img ? defaultSchema.attributes.img : []),
      'src','alt','title','width','height','srcset','sizes','loading','decoding','crossorigin'
    ],

    // code/pre
    code: [
      ...(defaultSchema.attributes && defaultSchema.attributes.code ? defaultSchema.attributes.code : []),
      'class','language','data-language'
    ],
    pre: [
      ...(defaultSchema.attributes && defaultSchema.attributes.pre ? defaultSchema.attributes.pre : []),
      'class'
    ],

    // table cells
    th: [
      ...(defaultSchema.attributes && defaultSchema.attributes.th ? defaultSchema.attributes.th : []),
      'colspan','rowspan','scope'
    ],
    td: [
      ...(defaultSchema.attributes && defaultSchema.attributes.td ? defaultSchema.attributes.td : []),
      'colspan','rowspan'
    ],

    // input and form elements (task list)
    input: [
      // must explicitly list allowed input attributes
      'type','checked','disabled','value','name','id','class','tabindex','aria-hidden','aria-label','aria-labelledby'
    ],
    label: [
      'for','class'
    ],
    button: [
      'type','disabled','aria-label','class'
    ],
    textarea: [
      'name','rows','cols','placeholder','readonly','disabled'
    ],
    select: [
      'name','multiple','size'
    ],
    option: [
      'value','selected','disabled'
    ]
  }
};
